[
  {
    "id": "staking_001",
    "language": "anchor",
    "project": "nft_staking",
    "source": "github",
    "filename": "initialize_config.rs",
    "code_snippet": "#[derive(Accounts)]\npub struct InitializeConfig<'info> {\n#[account(mut)]\npub admin: Signer<'info>,\n#[account(\ninit, \n        payer = admin,\n        seeds = [b\"config\".as_ref()],\n        bump,\n        space = 8 + Config::INIT_SPACE,\n    )]\n    pub config: Account<'info, Config>,\n    #[account(\n        init_if_needed,\n        payer = admin,\n        seeds = [b\"rewards\".as_ref(), config.key().as_ref()],\n        bump,\n        mint::decimals = 6,\n        mint::authority = config,\n    )]\n    pub rewards_mint: Account<'info, Mint>,\n    pub system_program: Program<'info, System>,\n    pub token_program: Program<'info, Token>,\n}",
    "comments": "// This struct is an anchor context that holds necessary accounts for initialize_config instruction",
    "dependencies": ["Config", "derive"],
    "line_numbers": [7, 29],
    "docstring": "an intialize_config anchor Context to Initiate a config PDA",
    "related_functions": []
  },
  {
    "id": "staking_002",
    "language": "anchor",
    "project": "nft_staking",
    "source": "github",
    "filename": "config.rs",
    "code_snippet": "#[account]\n#[derive(InitSpace)]\npub struct Config {  \npub points_per_stake: u8,  \npub max_stake: u8,  \npub freeze_period: u32,  \npub rewards_bump: u8, \npub bump: u8,\n}",
    "comments": "// This struct is an anchor account representing a Config PDA",
    "dependencies": ["account macro", "derive"],
    "line_numbers": [3, 11],
    "docstring": "Create Config pda struct for solana nft staking program program.",
    "related_functions": []
  },
  {
    "id": "staking_003",
    "language": "anchor",
    "project": "nft_staking",
    "source": "github",
    "filename": "intitialize_config.rs",
    "code_snippet": "pub fn initialize_config(&mut self, points_per_stake: u8, max_stake: u8, freeze_period: u32, bumps: &InitializeConfigBumps) -> Result<()> {  \nself.config.set_inner(Config {    \npoints_per_stake,   \nmax_stake,    \nfreeze_period,    \nrewards_bump: bumps.rewards_mint,   \nbump: bumps.config, \n}); \nOk(())\n}",
    "comments": "// This function sets inner fields of an initiated Config account",
    "dependencies": ["InitializeConfig"],
    "line_numbers": [32, 42],
    "docstring": "Set Config PDA account fields according to instruction parameters",
    "related_functions": []
  },
  {
    "id": "staking_004",
    "language": "anchor",
    "project": "nft_staking",
    "source": "github",
    "filename": "user.rs",
    "code_snippet": "#[account]\n#[derive(InitSpace)]\npub struct User {  \npub points: u32,  \npub amount_staked: u8,  \npub bump: u8,\n}",
    "comments": "// This struct is an anchor account representing a user PDA",
    "dependencies": ["account macro", "derive"],
    "line_numbers": [5, 9],
    "docstring": "user pda for anchor nft staking program.",
    "related_functions": []
  },
  {
    "id": "staking_005",
    "language": "anchor",
    "project": "nft_staking",
    "source": "github",
    "filename": "initialize_user.rs",
    "code_snippet": "#[derive(Accounts)]\npub struct Initialize<'info> {  \n#[account(mut)] \npub user: Signer<'info>,  \n#[account(    \ninit,   \npayer = user,   \nseeds = [b\"user\".as_ref(), user.key().as_ref()],    \nbump,   \nspace = 8 + User::INIT_SPACE, \n)]  \npub user_account: Account<'info, User>, \npub system_program: Program<'info, System>,\n}",
    "comments": "// This struct is an anchor context that holds necessary accounts for intiialize user instruction",
    "dependencies": ["User", "derive"],
    "line_numbers": [5, 18],
    "docstring": "an initialize_user anchor Context to make an user PDA for users of the nft staking platform",
    "related_functions": []
  },
  {
    "id": "staking_006",
    "language": "anchor",
    "project": "nft_staking",
    "source": "github",
    "filename": "initilize_user.rs",
    "code_snippet": "pub fn initialize_user(&mut self, bumps: &InitializeBumps) -> Result<()> { \nself.user_account.set_inner(User {    \npoints: 0,    \namount_staked: 0,   \nbump: bumps.user_account, \n}); \nOk(())\n}",
    "comments": "// This function sets inner fields of an initiated User account",
    "dependencies": ["User", "InitializeUser"],
    "line_numbers": [21, 29],
    "docstring": "Set user PDA account fields according to instruction parameters",
    "related_functions": []
  },
  {
    "id": "staking_007",
    "language": "anchor",
    "project": "nft_staking",
    "source": "github",
    "filename": "stake_account.rs",
    "code_snippet": "#[account]\n#[derive(InitSpace)] \npub struct StakeAccount {   \npub owner: Pubkey,    \npub mint: Pubkey,   \npub staked_at: i64,   \npub bump: u8,\n}",
    "comments": "// This struct is an anchor account representing a Stake Account PDA that implements Space trait",
    "dependencies": ["account macro", "derive"],
    "line_numbers": [3, 10],
    "docstring": "Create Stake Account pda struct for solana nft staking program program.",
    "related_functions": []
  },
  {
    "id": "staking_008",
    "language": "anchor",
    "project": "nft_staking",
    "source": "github",
    "filename": "stake.rs",
    "code_snippet": "#[derive(Accounts)]\npub struct Stake<'info> { \n#[account(mut)] \npub user: Signer<'info>, \npub mint: Account<'info, Mint>, \npub collection_mint: Account<'info, Mint>,\n#[account( \nmut, \nassociated_token::mint = mint, \nassociated_token::authority = user,\n)] \npub mint_ata: Account<'info, TokenAccount>,\n#[account( \nseeds = [  \nb\"metadata\",  \nmetadata_program.key().as_ref(),  \nmint.key().as_ref() \n], \nseeds::program = metadata_program.key(), \nbump, \nconstraint = metadata.collection.as_ref().unwrap().key.as_ref() == collection_mint.key().as_ref(), \nconstraint = metadata.collection.as_ref().unwrap().verified == true, \n)] \npub metadata: Account<'info, MetadataAccount>, \n#[account(\n    seeds = [\n        b\"metadata\",\n        metadata_program.key().as_ref(),\n        mint.key().as_ref(),\n        b\"edition\"\n    ],\n    seeds::program = metadata_program.key(),\n    bump,\n)]\npub edition: Account<'info, MasterEditionAccount>,\n#[account(\n    seeds = [b\"config\".as_ref()],\n    bump = config.bump,\n)]\npub config: Account<'info, Config>,\n#[account(\n    init,\n    payer = user,\n    space = 8 + StakeAccount::INIT_SPACE,\n    seeds = [b\"stake\".as_ref(), mint.key().as_ref(), config.key().as_ref()],\n    bump,\n)]\npub stake_account: Account<'info, StakeAccount>,\n#[account(\n    mut,\n    seeds = [b\"user\".as_ref(), user.key().as_ref()],\n    bump = user_account.bump,\n)]\npub user_account: Account<'info, User>,\npub system_program: Program<'info, System>,\npub token_program: Program<'info, Token>,\npub metadata_program: Program<'info, Metadata>,\n}",
    "comments": "// a stake anchor Context to stake a NFT for a user of the nft staking platform",
    "dependencies": ["StakeAccount", "derive"],
    "line_numbers": [17, 74],
    "docstring": "an stake anchor Context to stake a NFT for a user of the nft staking platform",
    "related_functions": []
  },
  {
    "id": "staking_009",
    "language": "anchor",
    "project": "nft_staking",
    "source": "github",
    "filename": "stake.rs",
    "code_snippet": "pub fn stake(&mut self, bumps: &StakeBumps) -> Result<()> {  \nrequire!(  \nself.user_account.amount_staked < self.config.max_stake,  \nStakeError::MaxStakeReached  \n);  \nself.stake_account.set_inner(StakeAccount {   \nowner: self.user.key(),   \nmint: self.mint.key(),    \nstaked_at: Clock::get()?.unix_timestamp,    \nbump: bumps.stake_account,  \n});  \nlet cpi_program = self.token_program.to_account_info();  \nlet cpi_accounts = Approve {    \nto: self.mint_ata.to_account_info(),  \ndelegate: self.stake_account.to_account_info(),  \nauthority: self.user.to_account_info(),  \n};  \nlet cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);  \napprove(cpi_ctx, 1)?;  \nlet seeds = &[    \nb`stake`,  \nself.mint.to_account_info().key.as_ref(),    \nself.config.to_account_info().key.as_ref(),   \n&[self.stake_account.bump],  \n  ];  \n  let signer_seeds = &[&seeds[..]];  \n  let delegate = &self.stake_account.to_account_info();  \n  let token_account = &self.mint_ata.to_account_info();  \n  let edition = &self.edition.to_account_info();  \n  let mint = &self.mint.to_account_info();  \n  let token_program = &self.token_program.to_account_info();  \n  let metadata_program = &self.metadata_program.to_account_info();  \n  FreezeDelegatedAccountCpi::new(  \n      metadata_program,  \n      FreezeDelegatedAccountCpiAccounts {  \n          delegate,  \n          token_account,  \n          edition,  \n          mint,  \n          token_program,  \n      },  \n  )  \n  .invoke_signed(signer_seeds)?;  \n  self.user_account.amount_staked += 1;  \n  Ok(())  \n}",
    "comments": "// This function stakes a user owned NFT and keeps track of the time stamp",
    "dependencies": [
      "FreezeDelegatedAccountCpi",
      "FreezeDelegatedAccountCpiAccounts",
      "Approve",
      "StakeAccount",
      "invoke_signed"
    ],
    "line_numbers": [77, 132],
    "docstring": "a stake function to freeze a user nft to get rewards depending on the time passed while staked",
    "related_functions": ["unstake"]
  },
  {
    "id": "staking_010",
    "language": "anchor",
    "project": "nft_staking",
    "source": "github",
    "filename": "unstake.rs",
    "code_snippet": "#[derive(Accounts)]\npub struct Unstake<'info> {\n#[account(mut)]\npub user: Signer<'info>,\npub mint: Account<'info, Mint>,\n#[account(\n    mut,\n    associated_token::mint = mint,\n    associated_token::authority = user,\n)]\npub mint_ata: Account<'info, TokenAccount>,\n#[account(\n    seeds = [\n        b'metadata',\n        metadata_program.key().as_ref(),\n        mint.key().as_ref(),\n        b'edition'\n    ],\n    seeds::program = metadata_program.key(),\n    bump,\n)]\npub edition: Account<'info, MasterEditionAccount>,\n#[account(\n    seeds = [b'config'.as_ref()],\n    bump = config.bump,\n)]\npub config: Account<'info, Config>,\n#[account(\n    mut,\n    close = user,\n    seeds = [b'stake'.as_ref(), mint.key().as_ref(), config.key().as_ref()],\n    bump,\n)]\npub stake_account: Account<'info, StakeAccount>,\n#[account(\n    mut,\n    seeds = [b'user'.as_ref(), user.key().as_ref()],\n    bump = user_account.bump,\n)]\npub user_account: Account<'info, User>,\npub system_program: Program<'info, System>,\npub token_program: Program<'info, Token>,\npub metadata_program: Program<'info, Metadata>,\n}",
    "comments": "// an unstake anchor Context to unstake a previously NFT for a user of the nft staking platform",
    "dependencies": ["StakeAccount", "derive"],
    "line_numbers": [17, 60],
    "docstring": "an unstake anchor Context to unstake a previously staked NFT for a user of the nft staking platform",
    "related_functions": []
  },
  {
    "id": "staking_011",
    "language": "anchor",
    "project": "nft_staking",
    "source": "github",
    "filename": "unstake.rs",
    "code_snippet": "pub fn unstake(&mut self) -> Result<()> {  \nlet time_elapsed =  \n      ((Clock::get()?.unix_timestamp - self.stake_account.staked_at) / 86400) as u32;\n        require!(\n            time_elapsed >= self.config.freeze_period,\n            StakeError::FreezePeriodNotPassed\n        );\n        self.user_account.points += time_elapsed as u32 * self.config.points_per_stake as u32;\n        let seeds = &[\n            b'stake',\n            self.mint.to_account_info().key.as_ref(),\n            self.config.to_account_info().key.as_ref(),\n            &[self.stake_account.bump],\n        ];\n        let signer_seeds = &[&seeds[..]];\n        let delegate = &self.stake_account.to_account_info();\n        let token_account = &self.mint_ata.to_account_info();\n        let edition = &self.edition.to_account_info();\n        let mint = &self.mint.to_account_info();\n        let token_program = &self.token_program.to_account_info();\n        let metadata_program = &self.metadata_program.to_account_info();\n        ThawDelegatedAccountCpi::new(\n            metadata_program,\n            ThawDelegatedAccountCpiAccounts {\n                delegate,\n                token_account,\n                edition,\n                mint,\n                token_program,\n            },\n        )\n        .invoke_signed(signer_seeds)?;\n        let cpi_program = self.token_program.to_account_info();\n        let cpi_accounts = Revoke {\n            source: self.mint_ata.to_account_info(),\n            authority: self.user.to_account_info(),\n        };\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        revoke(cpi_ctx)?;\n        self.user_account.amount_staked -= 1;\n        Ok(())\n}",
    "comments": "// This function stakes a user owned NFT and keeps track of the time stamp",
    "dependencies": [
      "ThawDelegatedAccountCpi",
      "ThawDelegatedAccountCpiAccounts",
      "Revoke",
      "CpiContext",
      "revoke"
    ],
    "line_numbers": [63, 115],
    "docstring": "a unstake function to thaw a staked user nft and stop getting staking rewards",
    "related_functions": ["stake"]
  },
  {
    "id": "staking_012",
    "language": "anchor",
    "project": "nft_staking",
    "source": "github",
    "filename": "claim.rs",
    "code_snippet": "#[derive(Accounts)]\npub struct Claim<'info> {\n    #[account(mut)]\n    pub user: Signer<'info>,\n    #[account(\n        mut,\n        seeds = [b'user'.as_ref(), user.key().as_ref()],\n        bump = user_account.bump,\n    )]\n    pub user_account: Account<'info, User>,\n    #[account(\n        mut,\n        seeds = [b'rewards'.as_ref(), config.key().as_ref()],\n        bump = config.rewards_bump\n    )]\n    pub rewards_mint: Account<'info, Mint>,\n    #[account(\n        seeds = [b'config'.as_ref()],\n        bump = config.bump,\n    )]\n    pub config: Account<'info, Config>,\n    #[account(\n        init_if_needed,\n        payer = user,\n        associated_token::mint = rewards_mint,\n        associated_token::authority = user,\n    )]\n    pub rewards_ata: Account<'info, TokenAccount>,\n    pub system_program: Program<'info, System>,\n    pub token_program: Program<'info, Token>,\n    pub associated_token_program: Program<'info, AssociatedToken>,\n}",
    "comments": "// a claim anchor Context to claim rewards of the nft staking platform",
    "dependencies": ["User", "Config", "derive"],
    "line_numbers": [9, 40],
    "docstring": "a claim anchor Context to claim user rewards of the nft staking platform",
    "related_functions": []
  },
  {
    "id": "staking_013",
    "language": "anchor",
    "project": "nft_staking",
    "source": "github",
    "filename": "claim.rs",
    "code_snippet": "pub fn claim(&mut self) -> Result<()> {\n      let cpi_program = self.token_program.to_account_info();\n      let seeds = &[b'config'.as_ref(), &[self.config.bump]];\n      let signer_seeds = &[&seeds[..]];\n      let cpi_accounts = MintTo {\n          mint: self.rewards_mint.to_account_info(),\n          to: self.rewards_ata.to_account_info(),\n          authority: self.config.to_account_info(),\n      };\n      let cpi_context = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);\n      mint_to(\n          cpi_context,\n          self.user_account.points as u64 * 10_u64.pow(self.rewards_mint.decimals as u32),\n      )?;\n      self.user_account.points = 0;\n      Ok(())\n  }",
    "comments": "// This function claims user NFT staking rewards",
    "dependencies": ["MintTo", "CpiContext", "mint_to"],
    "line_numbers": [43, 65],
    "docstring": "a claim function to retrieve user nft rewards",
    "related_functions": []
  }
]
